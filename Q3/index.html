<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Babylon.js AR (module build)</title>
    <style>
      html, body { width:100%; height:100%; margin:0; overflow:hidden; }
      #renderCanvas { width:100%; height:100%; touch-action:none; }
    </style>
  </head>
  <body>
    <canvas id="renderCanvas"></canvas>

    <script type="module">
      const CORE = "https://cdn.jsdelivr.net/npm/@babylonjs/core@latest";
      const LOADERS = "https://cdn.jsdelivr.net/npm/@babylonjs/loaders@latest";
      import * as BABYLON from `${CORE}/+esm`;
      import { LoadAssetContainerAsync } from `${CORE}/Loading/sceneLoader.js`;
      import `${LOADERS}/glTF/2.0/glTFLoader.js`;
      const canvas = document.getElementById("renderCanvas");
      const engine = new BABYLON.Engine(canvas, true, {
        preserveDrawingBuffer: true,
        stencil: true
      });

      async function createScene() {
        const scene = new BABYLON.Scene(engine);

        new BABYLON.HemisphericLight("lite", new BABYLON.Vector3(0, 1, 0), scene).intensity = 0.6;
        const container = await LoadAssetContainerAsync("/model/", "pikachu2.glb", scene);
        const template = container.createRootMesh();   // TransformNode / root
        container.addAllToScene();
        template.setEnabled(false);
        template.scaling = new BABYLON.Vector3(0.4, 0.4, 0.4);
        const xr = await BABYLON.WebXRDefaultExperience.CreateAsync(scene, {
          uiOptions: { sessionMode: "immersive-ar", referenceSpaceType: "local" },
          optionalFeatures: true
        });

        const fm = xr.baseExperience.featuresManager;
        const hitTest = fm.enableFeature(BABYLON.WebXRFeatureName.HIT_TEST, "latest", {
          offsetRay: new BABYLON.Ray(new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 0, -1)),
          entityTypes: ["plane"]
        });

        let lastHit = null;
        hitTest.onHitTestResultObservable.add(results => {
          lastHit = results.length ? results[0] : null;
        });

        let selected = null;
        xr.input.onControllerAddedObservable.add(xrController => {
          if (xrController.inputSource.handedness !== "right") return;

          xrController.onMotionControllerInitObservable.add(mc => {
            const trigger = mc.getComponent("xr-standard-trigger");
            trigger.onButtonStateChangedObservable.add(() => {
              if (trigger.pressed && lastHit) {
                const clone = template.clone("spawn_" + Date.now());
                clone.setEnabled(true);
                clone.position.copyFrom(lastHit.position);

                const fwd = xr.baseExperience.camera.getForwardRay().direction;
                clone.rotationQuaternion = BABYLON.Quaternion.FromLookDirectionLH(
                  new BABYLON.Vector3(fwd.x, 0, fwd.z).normalize(),
                  BABYLON.Axis.Y
                );
                selected = clone;
              }
            });
          });
        });

        const speed = 0.6;
        scene.onBeforeRenderObservable.add(() => {
          if (!selected) return;
          const right = xr.input.controllers.find(c => c.inputSource.handedness === "right");
          if (!right || !right.motionController) return;

          const stick = right.motionController.getComponent("xr-standard-thumbstick");
          if (!stick) return;

          const dt = scene.getEngine().getDeltaTime() / 1000;
          const cam = xr.baseExperience.camera;
          const camForward = cam.getForwardRay().direction;
          const forward2D = new BABYLON.Vector3(camForward.x, 0, camForward.z).normalize();
          const right2D = BABYLON.Vector3.Cross(forward2D, BABYLON.Axis.Y).negate().normalize();

          const moveVec = right2D.scale(stick.axes.x * speed * dt)
            .add(forward2D.scale(stick.axes.y * speed * dt));
          selected.position.addInPlace(moveVec);
        });

        return scene;
      }

      const scene = await createScene();

      engine.runRenderLoop(() => {
        if (scene.activeCamera) scene.render();
      });

      window.addEventListener("resize", () => engine.resize());
    </script>
  </body>
</html>
